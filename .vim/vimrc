""" General
" load filetype settings, plugins and maps
filetype plugin indent on
syntax on

" allow buffers to have changes without being displayed
set hidden
set number relativenumber
"set number
set signcolumn=number
set cursorline

set scrolloff=5
set backspace=indent,eol,start  "backspace over anything
set ttimeout ttimeoutlen=30     "timeout on keycodes

set virtualedit=block,onemore   "move past end of line in v-block mode and 1 past end of line in normal mode

" cmd
set showcmd
set cmdheight=2
set shortmess-=S

" reload file when edited outside vim
set autoread

set confirm

" enable project-specific vimrc
set exrc
set secure

let g:filetype_pl="prolog"

""" OS
if !exists("g:os")
    if has("win32") || has("win64")
        let g:os = "Windows"
    elseif has("unix")
        let g:os = "Linux"
    else
        let g:os = ""
    endif
endif

""" Plugins
if g:os == "Linux"
    if empty(glob('~/.vim/autoload/plug.vim'))
      silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
        \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
      autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
    endif
endif

call plug#begin('~/.vim/vim_plug')

Plug 'romainl/vim-cool'
Plug 'romainl/vim-qf'
Plug 'tpope/vim-abolish'
"Plug 'ludovicchabant/vim-gutentags'
Plug 'arcticicestudio/nord-vim'
if has('nvim')
    function! UpdateRemotePlugins(...)
        " Needed to refresh runtime files
        let &rtp=&rtp
        UpdateRemotePlugins
    endfunction

    "Plug 'sakhnik/nvim-gdb', { 'do': ':!./install.sh' }
    Plug 'neovim/nvim-lspconfig'
    "Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}
    Plug 'gelguy/wilder.nvim', { 'do': function('UpdateRemotePlugins') }

    Plug 'nixprime/cpsm'
    Plug 'romgrk/fzy-lua-native'

    "Plug 'shaunsingh/nord.nvim'
    "Plug 'andersevenrud/nordic.nvim'
else
    Plug 'dense-analysis/ale'
endif

call plug#end()

let g:ale_linters = {
\ 'c': ['clangcheck', 'clangd', 'clangtidy', 'cppcheck', 'cpplint'],
\ 'cpp': ['clangcheck', 'clangd', 'clangtidy', 'cppcheck', 'cpplint'],
\ 'haskell': ['cabal_ghc', 'hdevtools', 'hie', 'hlint', 'stack_build', 'stack_ghc']
\}

let g:ale_python_pylint_options = '--disable=C'

let g:ale_echo_msg_format = '%linter%: %s'

let g:gutentags_ctags_tagfile = '.tags'
let g:gutentags_project_root = ['.tags']
let g:gutentags_add_default_project_roots = 0
let g:gutentags_add_ctrlp_root_markers = 0
set tags=./.tags;,.tags;

""" Wildmenu
set wildmenu                    " Use wildmenu
set wildmode=list:longest,full  " Tab press completes longest common match and lists, second press cycles
set wildignorecase              " Case insensitive, if supported
set wildcharm=<C-z>

"TODO wildignore
call wilder#setup({
    \ 'modes': [':'],
    \ 'next_key': '<Tab>',
    \ 'previous_key': '<S-Tab>',
    \ 'accept_key': '<C-n>',
    \ 'reject_key': '<C-p>',
    \ })

call wilder#set_option('pipeline', [
    \   wilder#branch(
    \     wilder#python_file_finder_pipeline({
    \       'file_command': {_, arg -> stridx(arg, '.') != -1 ? ['fd', '-tf', '-H'] : ['fd', '-tf']},
    \       'dir_command': ['fd', '-td'],
    \       'filters': ['cpsm_filter'],
    \     }),
    \     wilder#cmdline_pipeline({
    \       'fuzzy': 2,
    \       'fuzzy_filter': has('nvim') ? wilder#lua_fzy_filter() : wilder#vim_fuzzy_filter(),
    \     }),
    \     [
    \       wilder#check({_, x -> empty(x)}),
    \       wilder#history(),
    \     ],
    \   ),
    \ ])

let s:highlighters = [
      \ wilder#pcre2_highlighter(),
      \ has('nvim') ? wilder#lua_fzy_highlighter() : wilder#cpsm_highlighter(),
      \ ]

call wilder#set_option('renderer',
    \ wilder#popupmenu_renderer(wilder#popupmenu_border_theme({
    \     'max_height': 12,
    \     'max_width': '100%',
    \     'border': 'rounded',
    \     'empty_message': wilder#popupmenu_empty_message_with_spinner(),
    \     'highlighter': s:highlighters,
    \     'left': [
    \        ' ',
    \        wilder#popupmenu_buffer_flags({
    \          'flags': '1u% +- ',
    \          'icons': {'%': '', '#': '', '+': '', '=': '', '-': ''},
    \        }),
    \     ],
    \     'right': [
    \        ' ',
    \        wilder#popupmenu_scrollbar(),
    \     ],
    \ })))

""" Indent & Whitespace
set autoindent               " Use indent of previous line on new lines
set expandtab                " Use spaces instead of tabs
set shiftwidth=4             " Indent with four spaces
set softtabstop=4            " Insert four spaces with tab key
set breakindent              " Indent wrapped lines
"set breakindentopt=shift:2   " Indent wrapped lines slightly more
set breakindent showbreak=>\ 
set linebreak                " Break at word boundaries

set shiftround
set smarttab

" show trailing spaces
set list
"set listchars=tab:\ \ ,trail:·
set listchars=tab:>\ ,trail:·,extends:>,precedes:<

""" History, Swap, Undo, Backup
set history=300

set backup
set undofile
" keep swap, backup and undo files in dedicated directory
" // expands to file's full path
if g:os == "Linux"
    let s:version = 'vim'
    if has('nvim')
        let s:version = 'nvim'
    endif

    let s:directory = $XDG_STATE_HOME."/".s:version."/swap"
    if !isdirectory(s:directory)
        call mkdir(s:directory, "p", 0700)
    endif
    let &directory=s:directory.",/var/tmp,/tmp"

    let s:directory = $XDG_STATE_HOME."/".s:version."/backup"
    if !isdirectory(s:directory)
        call mkdir(s:directory, "p", 0700)
    endif
    let &backupdir=s:directory

    let s:directory = $XDG_STATE_HOME."/".s:version."/undo"
    if !isdirectory(s:directory)
        call mkdir(s:directory, "p", 0700)
    endif
    let &undodir=s:directory

    " no undo or backup files for files in /tmp
    au BufWritePre /tmp/* setlocal noundofile nobackup nowritebackup
else
    set directory^=~/vimfiles/cache/swap//
    set backupdir^=~/vimfiles/cache/backup//
    set undodir^=~/vimfiles/cache/undo//
endif

""" Path
" set path in filetype specific settings
set path-=/usr/include

""" Completion
set completeopt=                "control completion menu
set completeopt+=longest        "match longest common text
set completeopt+=menuone        "show menu even if there's only 1 match

"enter to select highlighted menu item
inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"

"simulate <Down> to keep a menu item highlighted when using <C-N>
inoremap <expr> <C-n> pumvisible() ? '<C-n>' :
  \ '<C-n><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'

"simulate <Up> to keep a menu item highlighted when using <C-P>
inoremap <expr> <C-p> pumvisible() ? '<C-p>' :
  \ '<C-p><C-r>=pumvisible() ? "\<lt>Up>" : ""<CR>'


""" Search
set hlsearch
set ignorecase
set incsearch

if executable('rg')
    set grepprg=rg\ -S\ --vimgrep
    set grepformat=%f:%l:%c:%m
endif

""" Fold
set foldenable
set modeline
set modelineexpr

""" Colorscheme + Font
colorscheme nord
set bg=dark
if g:os == "Linux"
    set guifont=Fira_Code_Medium:h11
elseif g:os == "Windows"
    set guifont=Consolas:h11
endif

""" GUI
set guioptions-=m "menu bar
set guioptions-=T "toolbar
set guioptions-=r "scrollbar

""" Statusline
set laststatus=2

""" netrw
let g:netrw_banner = 0
let g:netrw_liststyle = 3
let g:netrw_winsize = 20
let g:netrw_dirhistmax=0

""" Keybindings
" use leader for buffer/pane operations
let mapleader = ","
let maplocalleader = "\<Space>"
" toggle folds with <space><space>
"nnoremap <silent> <localleader><Space> @=(foldlevel('.')?'za':"\<Space>")<CR>
"vnoremap <localleader><space> zf
nnoremap <localleader><space> <C-^>
nmap <localleader><backspace> <Plug>(qf_qf_switch)

nnoremap U <C-R>
nnoremap Y y$
nnoremap Q gQ

" expand %% in command mode to current file path
"cnoremap %% <C-R>=fnameescape(expand('%:h')).'/'<CR>

" search recursively for edit and find
"nnoremap <leader>e :e **/*<C-z>**/*
"nmap <leader>e :e %%<C-z><S-Tab>
nnoremap <leader>e :e <C-R>=fnameescape(expand('%:h')).'/'<CR><C-z>
cnoremap <expr> f<Space> getcmdline() == '' ? 'find **/*' : 'f '

" cd to current file path for current window
nnoremap <leader>cd :lcd %:h<CR>

" list loaded buffers and populate prompt
nnoremap gb :ls<CR>:b<Space>

" Cycle through argument list
nnoremap [a :previous<CR>
nnoremap ]a :next<CR>
" Cycle through buffers
nnoremap [b :bprevious<CR>
nnoremap ]b :bnext<CR>
" Cycle through quicklist/:helpgrep items
"nnoremap [c :cprevious<CR>
"nnoremap ]c :cnext<CR>
nmap [c <Plug>(qf_qf_previous)
nmap ]c  <Plug>(qf_qf_next)
" Cycle through location list items
"nnoremap [l :lprevious<CR>
"nnoremap ]l :lnext<CR>
nmap [l <Plug>(qf_loc_previous)
nmap ]l  <Plug>(qf_loc_next)

nnoremap <localleader>y :%y+<CR>

"" vim:fdm=expr:fdl=0
"" vim:fde=getline(v\:lnum)=~'^""'?'>'.(matchend(getline(v\:lnum),'""*')-2)\:'='
